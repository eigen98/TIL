# CriminalIntent

# chapter11 
## RoomDatabase

장시간 데이터를 저장할 곳이 필요한 상황에는 어디에 저장을 할까?
이 챕터에서는 룸 라이브러리를 사용하여 데이터베이스를 쿼리할 수 있는 코드를 구현할 예정.

chapter4에서 장치 회전 및 프로세스 종료 시 **ViewModel과 SIS**를 사용하여 일시적 UI상태 데이터를 지속하였음.
UI와 무관하게 영구적으로 지속할 필요가 있는 데이터 저장에 사용 불가

**room**은 Jetpack의 아키텍처 컴포넌트 라이브러리.
데이터베이스 설정과 사용을 쉽게 도와줌.(애노테이션이 지정된 코틀린클래스로 데이터베이스 구조와 쿼리 정의)

###룸의 구성 
- API
- Annotation
- 컴파일러 

### 데이터 베이스 생성(룸은 아래 세가지를 수월하게 만들어줌)
- **모델 클래스**에 애노테이션을 지정(데이터베이스 Entity로 만든다)      
     @Entity를 앞에 붙임.
     데이터베이스 테이블의 구조를 정의함
     테이블의 각 행(row)을 담당
     속성에 @Primary키 애노테이션을 추가하므로서 기본키 지정
- **데이터베이스 자체를 나타내는 클래스** 생성
    특정 엔티티 클래스는 여러 데이터베이스에서 사용가능. 따라서 엔티티 클래스를 데이터베이스와 연관시켜주어야함. 
    @Database 에노테이션은 해당 클래스가 데이터베이스라는 표시
    첫번 째 매개변수 : 사용할 엔티티 클래스
    두번 째 매개변수 : 데이터베이스 버전
    RoomDatabase의 서브클래스, abstract로 지정
    
- 데이터베이스가 모델 데이터를 처리할 수 있게 **타입 변환기** 생성
	룸은 내부적으로 SQLite를 사용.
    오픈소스 관계형 데이터베이스
    코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑(ORM)
    룸은 기본데이터 타입을 SQLite DB에 쉽게 저장할 수 있지만, 다른타입은 문제발생(타입변환기 필요성)
    변환기 클래스 안에 @TypeConverter애노테이션을 사용하여 함수 선언
    변환기 클래스를 데이터베이스 클래스에 추가.
    
### DAO 정의
- DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스 -> 구현하는 클래스 룸이 생성
- DB 테이블 데이터에 액세스하기 위해 DAO(Data Access Object)필요
- @DAO 애노테이션 지정 -> Room이 DAO중 하나임을 알게됨
- 데이터베이스 클래스에 Dao를 등록
- @Query 애노테이션은 함수가 데이터베이스의 데이터를 읽는 다는 것을 나타냄
- @Query 애노테이션은 문자열로 된 SQL 명령을 받는다.

### 리포지터리 패턴으로 데이터베이스 액세스
- 데이터베이스를 액세스를 위해 구글 앱 아키텍처 지침에서 권장하는 리포지터리 패턴사용
	**리포지터리 클래스** 리포지토리(데이터 저장소) 구현
- 레포지토리 구현
	싱글톤 패턴으로 구현 (앱이 실행되는 동안 하나의 인스턴스만 생성)
    액티비티나 프래그먼트의 생명주기 상태가 변경되어도 계속 유지
    데이터를 갖고 있으면서 컨트롤러 클래스 간의 데이터를 쉽게 전달하는 방법을 제공
    생성자 private으로 지정(앱이 시작될 때만 생성-> Application 서브클래스)
- Application.onCreate()
	앱이 최초로 메모리에 로드될 때 안드로이드 시스템이 자동호출 . 한번만 초기화되는 작업 수행에 적합
    매니페스트에 등록필요.
- 레포지토리에 데이터베이스 객체와 DAO객체의 참조를 저장하는 두개의 속성 추가.
	Room.databaseBuilder() -> 데이터베이스 실체 클래스 생성.
- Dao 데이터베이스 액세스 함수들을 레포지토리에서 사용하기 위한 함수를 추가.

### 쿼리 테스트하기
----------------------
리포지터리가 준비된 상황

**모의데이터 업로드** 할 때?

	장치 파일 탐색기(Device File Explore)를 이용하여 에뮬레이터에 파일을 업로드.

 - [ ] 에뮬레이터는 루트권한으로 사용가능하지만 실제 장치는 권한이 없어서 불가.


### 테스트 데이터베이스 업로드
----------------------
안드로이드 장치의 각 애플리케이션은 자신의 **샌드박스**에 디렉터리를 가짐

	샌드박스란 외부로부터 들어온 프로그램이 보호된 영역에서 동작해 시스템이 부정하게 조작되는 것을 막는 보안형태
	안드로이드는 외부에서 다운받은 앱을Dalvic샌드박스 내에서만 실행시켜 시스템을 보호

샌드박스에 파일 저장 시 다른 사용자 액세스 방지(루팅 제외)

샌드박스 디렉터리는 **/data/data/패키지이름** 

샌드박스 디렉터리에 업로드하여 모의데이터 테스트

### 어플리케이션 스레드
----------------------
어플 실행시 **에러가 발생**하는데 이는 UI를 차단하는 **데이터베이스 액세스를 main 스레드에서 사용**하였기 때문.

데이터베이스 액세스와 같은 작업은 **백그라운드에서 수행**.

**스레드**란

	단일의 실행 시퀀스
모든 안드로이드 앱은 **main스레드**로 시작.
	
	main스레드는 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다림.

 - main스레드는 UI를 변경하는 모든 코드를 실행
 - 어떤 형태로든 모두 UI와 관련이 있어서 main스레드를 UI스레드라고도 함.

### 백그라운드 스레드
----------------------
데이터베이스 액세스로 인해 UI는 멈추고 ANR결과 초래

-> 백그라운드 스레드를 생성하여 데이터베이스 액세스

**백그라운드 스레드 추가시 규칙 2가지**
- 장시간 실행되는 모든 작업은 모두 백그라운드 스레드로 수행.
- UI는 main스레드에서만 변경 가능.

**백그라운드 스레드로 작업하는 방법**

- 비동기 네트워크 요청(24장)
- 핸들러 사용(25장)
- WorkManager 사용하여 주기적인 백그라운드 작업(27장)
- **LiveData, Executor사용**

### LiveData 사용하기
----------------------
**LiveData란?**
	Jetpack의 lifecycle-extensions라이브러리에 있는 데이터 홀더 클래스. 
	룸에서 LiveData 사용.

- **LiveData의 목적**은 앱의 서로 다른 부분간 데이터 전달을 쉽게 만드는 것 
- 스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main스레드로 전달 가능


>  1. Room Dao의 쿼리에서 LiveData반환하도록 구성.
>  
>  2. Room이 백그라운드 스레드에서 쿼리 작업 자동 실행후 LiveData 객체 반환.
>  
>  3. 액티비티나 프래그먼트에서 LiveData객체 관찰하도록 설정

뷰모델에 저장된 LiveData를 참조

LiveData로 반환될 때 프래그먼트에서 Observer 사용

LiveData.observer함수는 LiveData인스턴스에 옵저버를 등록하기위해 사용.


